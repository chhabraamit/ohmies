package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
)

const debug = false

var walletAddress = "0x663e5582A647B3b6fb351ee43B3f8213cB5D6532"
var isKlima = false
var baseUrl = "https://api.etherscan.io/api"
var ohmContract = "0x383518188c0c6d7730d91b2c03a03c837814a899"
var sOhmContract = "0x04f2694c8fcee23e8fd0dfea1d4f5bb8c352111f"
var ApiKey = "1PZ9CGXZPQ1PT1SVM5V8KY9NAGJA3YJB93"
var ohmPriceUrl = "https://api.coingecko.com/api/v3/simple/price?ids=Olympus&vs_currencies=USD"

// ohmies -w <address> -klima
// ohmies -w <address>
func main() {
	var showKlima = flag.Bool("klima", false, "show klima value")
	var walletAddressPtr = flag.String("w", "", "wallet address")
	flag.Parse()
	//fmt.Printf("show klima: %v\n", *showKlima)

	//walletAddress = os.Args[1]
	fmt.Printf("walletAddress: %v\n", *walletAddressPtr)
	walletAddress = *walletAddressPtr
	isKlima = *showKlima
	initUrls()

	sOhm := getSOhm()
	var name = "Ohm"
	if isKlima{
		name="Klaima"
	}
	fmt.Printf("current%v: %v\n",name, sOhm)

	ohmPrice := getOhmPrice()
	fmt.Printf("%vPrice: %v\n", name, ohmPrice)

	stakedOhms, startingDate := getStakedOhms()
	fmt.Printf("invested%vs: %v\n", name,stakedOhms)

	fmt.Printf("investedPrice: %v\n", stakedOhms * ohmPrice)

	ohmGain := sOhm - stakedOhms
	fmt.Printf("gain in %v: %v\n",name, ohmGain)

	fmt.Printf("current USD assets: %v\n", sOhm * ohmPrice)
	gains := ohmGain * ohmPrice
	fmt.Printf("gain in USD: %v\n", gains)

	fmt.Println()

	fmt.Printf("started at: %v\n", startingDate)

	now := time.Now()
	days := int(now.Sub(startingDate).Hours()) / (24)
	fmt.Printf("total days staked: %v\n", days)
	fmt.Printf("per day gain (in USD): %v\n", gains/(float64(days)))


}

func initUrls() {
	if isKlima {
		baseUrl = "https://api.polygonscan.com/api"
		ohmContract = "0x4e78011ce80ee02d2c3e649fb657e45898257815"
		sOhmContract = "0xb0C22d8D350C67420f06F48936654f567C73E8C8"
		ApiKey = "8DWJHJNXDHC9FVZ21NKAW6MB6V3QCARIAX"
		ohmPriceUrl = "https://api.coingecko.com/api/v3/simple/price?ids=klima-dao&vs_currencies=USD"
	}
}

func getStakedOhms() (float64, time.Time) {
	url := strings.Join([]string{baseUrl, "?module=account&action=tokentx&contractaddress=", ohmContract, "&address=", walletAddress, "&page=1&offset=100&sort=asc&apikey=", ApiKey}, "")
	if debug {
		fmt.Printf("url for stakedOhms: %v\n", url)
	}
	type AutoGenerated struct {
		Status  string `json:"status"`
		Message string `json:"message"`
		Result  []struct {
			BlockNumber       string `json:"blockNumber"`
			TimeStamp         string `json:"timeStamp"`
			Hash              string `json:"hash"`
			Nonce             string `json:"nonce"`
			BlockHash         string `json:"blockHash"`
			From              string `json:"from"`
			ContractAddress   string `json:"contractAddress"`
			To                string `json:"to"`
			Value             string `json:"value"`
			TokenName         string `json:"tokenName"`
			TokenSymbol       string `json:"tokenSymbol"`
			TokenDecimal      string `json:"tokenDecimal"`
			TransactionIndex  string `json:"transactionIndex"`
			Gas               string `json:"gas"`
			GasPrice          string `json:"gasPrice"`
			GasUsed           string `json:"gasUsed"`
			CumulativeGasUsed string `json:"cumulativeGasUsed"`
			Input             string `json:"input"`
			Confirmations     string `json:"confirmations"`
		} `json:"result"`
	}
	v := AutoGenerated{}

	err, body := getBytes(url)
	if err != nil {
		log.Fatalln(err)
	}
	if debug {
		fmt.Printf("string: %v\n", string(body))
	}
	err = json.Unmarshal(body, &v)
	if err != nil {
		log.Fatalln(err)
	}
	ans := 0.0
	startingDate := time.Now()
	getValue := func(str string) float64 {
		a, err := strconv.Atoi(str)
		if err != nil {
			log.Fatal(err)
		}
		ans := float64(a)
		i := 1000000000.0
		ans = ans / (1.0 * i)
		return ans
	}
	for _, txn := range v.Result {
		if strings.ToLower(txn.To) == strings.ToLower(walletAddress) {
			ans += getValue(txn.Value)
			curr := getTime(txn.TimeStamp)
			if curr.Before(startingDate) {
				startingDate = curr
			}
		}
	}
	return ans, startingDate
}

func getTime(stamp string) time.Time {
	i, err := strconv.Atoi(stamp)
	if err != nil {
		log.Fatal(err)
	}
	ts := time.Unix(int64(i), 0)
	parse, err := time.Parse("2006-01-02", ts.String()[0:len("2021-10-16")])
	if err != nil {
		log.Fatal(err)
	}
	//fmt.Printf("time: %v\n", parse)
	return parse
}

func getOhmPrice() float64 {

	url := ohmPriceUrl
	o := struct {
		//{"olympus":{"usd":1037.62}}
		Olympus struct {
			USD float64 `json:"usd"`
		} `json:"olympus"`
	}{}

	k := struct {
		//{"olympus":{"usd":1037.62}}
		Olympus struct {
			USD float64 `json:"usd"`
		} `json:"klima-dao"`
	}{}

	err, body := getBytes(url)

	//fmt.Printf("string: %o\n", string(body))
	if isKlima{
		err = json.Unmarshal(body, &k)
		if err != nil {
			log.Fatalln(err)
		}
		//Convert the body to type string
		return k.Olympus.USD
	}
	err = json.Unmarshal(body, &o)
	if err != nil {
		log.Fatalln(err)
	}
	//Convert the body to type string
	return o.Olympus.USD
}

func getSOhm() float64 {
	url := strings.Join([]string{baseUrl, "?module=account&action=tokenbalance&contractaddress=", sOhmContract, "&address=", walletAddress, "&tag=latest&apikey=", ApiKey}, "")
	v := struct {
		Result string `json:"result"`
	}{}

	err, body := getBytes(url)

	//fmt.Printf("string: %v\n", string(body))
	err = json.Unmarshal(body, &v)
	if err != nil {
		log.Fatalln(err)
	}
	//Convert the body to type string
	a, err := strconv.Atoi(v.Result)
	if err != nil {
		log.Fatal(err)
	}
	ans := float64(a)
	i := 1000000000.0
	ans = ans / (1.0 * i)
	return ans
}

func getBytes(url string) (error, []byte) {
	resp, err := http.Get(url)
	if err != nil {
		log.Fatalln(err)
	}
	//We Read the response body on the line below.
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}
	return err, body
}
